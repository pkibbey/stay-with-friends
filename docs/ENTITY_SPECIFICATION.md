# Stay With Friends - Entity Specification

## Overview

Stay With Friends is a platform that enables friends to share their homes with each other, creating a trusted network of accommodations. The application facilitates hosting opportunities, availability management, booking requests, and social connections between friends.

### Core Concepts

The platform operates on several key principles:
- **Trust-based Network**: Users connect with friends to create a trusted accommodation network
- **Host-Guest Relationships**: Friends can offer their homes as hosts and stay as guests
- **Availability Management**: Hosts control when their properties are available for stays
- **Booking Coordination**: Simple request system for coordinating stays between friends
- **Social Connections**: User network management for building trusted relationships

---

## Entity Definitions

### 1. User Entity

**Purpose**: Represents registered users of the platform who can both host and request accommodations.

**Properties** (API responses use snake_case to match the database schema):
- `id` (string): UUID primary key generated by the backend (for new rows we call `crypto.randomUUID()`)
- `email` (string, required, unique): User's email address for authentication and communication
- `name` (string, optional): Display name of the user
- `email_verified` (string, optional): Timestamp when email was verified
- `image` (string | null, optional): URL to user's profile picture or `null`
- `created_at` (string, required): Timestamp when the user record was created

**Relationships**:
- One-to-Many with `Host` (user can create multiple hosting properties)
- One-to-Many with `Connection` (user can have multiple friend connections)
- One-to-Many with `BookingRequest` (user can make multiple booking requests)
- One-to-Many with `Invitation` (user can send multiple invitations)

**Business Rules**:
- Email must be unique across the platform (enforced via `idx_users_email` index)
- Email verification is optional; the platform accepts unverified users and tracks the timestamp when verification occurs
- Users can act as both hosts and guests

**Database Schema**:
```sql
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  name TEXT,
  email_verified DATETIME,
  image TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_users_created_at ON users(created_at);
```

---

### 2. Host Entity (Host Property/Listing)

**Purpose**: Represents a property or accommodation that a user offers to friends for stays.

**Properties** (snake_case from the REST API / database; frontend utilities can convert to camelCase when needed):
- `id` (string): UUID primary key for the property
- `user_id` (string | null): Owner user ID. Nullable because the backend allows seed data without a user record
- `name` (string, required): Property name (e.g., "Cozy Downtown Apartment")
- `email` (string | null): Optional contact email (unique when present)
- `location` (string | null): General location description
- `description` (string | null): Detailed description of the property
- `address` (string | null): Street address
- `city` / `state` / `zip_code` / `country` (string | null): Address metadata
- `latitude` / `longitude` (string | null): Geographic coordinates (stored as text, parsed to numbers by shared-types helpers)
- `amenities` (string[] | null): List of amenities, stored as JSON text in SQLite
- `house_rules` (string | null): Rules and guidelines for guests
- `check_in_time` / `check_out_time` (string | null): Standard check-in/out times
- `max_guests`, `bedrooms`, `bathrooms` (number | null): Capacity metadata
- `photos` (string[] | null): Array of photo URLs, stored as JSON text
- `created_at` / `updated_at` (string): Timestamps generated by the database

**Relationships**:
- Many-to-One with `User` (user owns the hosting)
- One-to-Many with `Availability` (host has multiple availability periods)
- One-to-Many with `BookingRequest` (host can receive multiple booking requests)

**Business Rules**:
- Name is required for all hosts (validated before insert)
- Email is optional but must be unique when present (`idx_hosts_email_unique`)
- Geographic metadata is optional; search endpoints look at `name` and `location`
- Amenities and photo arrays are stored as JSON strings and parsed via `fromDbRow`

**Database Schema**:
```sql
CREATE TABLE IF NOT EXISTS hosts (
  id TEXT PRIMARY KEY,
  user_id TEXT,
  name TEXT NOT NULL,
  email TEXT UNIQUE,
  location TEXT,
  description TEXT,
  address TEXT,
  city TEXT,
  state TEXT,
  zip_code TEXT,
  country TEXT,
  latitude TEXT,
  longitude TEXT,
  amenities TEXT,
  house_rules TEXT,
  check_in_time TEXT,
  check_out_time TEXT,
  max_guests INTEGER,
  bedrooms INTEGER,
  bathrooms INTEGER,
  photos TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_hosts_location ON hosts(location);
CREATE INDEX IF NOT EXISTS idx_hosts_city_state ON hosts(city, state);
CREATE INDEX IF NOT EXISTS idx_hosts_created_at ON hosts(created_at);
CREATE INDEX IF NOT EXISTS idx_hosts_coordinates ON hosts(latitude, longitude);
CREATE INDEX IF NOT EXISTS idx_hosts_user_id ON hosts(user_id);
CREATE UNIQUE INDEX IF NOT EXISTS idx_hosts_email_unique ON hosts(email) WHERE email IS NOT NULL;
```

---

### 3. Availability Entity

**Purpose**: Represents specific date ranges when a host property is available for bookings.

**Properties**:
- `id` (string): UUID primary key for the availability period
- `host_id` (string, required): Reference to the host property
- `start_date` / `end_date` (string, required): ISO date strings defining the range (inclusive)
- `status` (string, required): Current status (`"available"`, `"booked"`, or `"blocked"`)
- `notes` (string | null): Optional free-form text

**Relationships**:
- Many-to-One with `Host` (availability belongs to a host)

**Business Rules**:
- Start date must be before or equal to end date (validated in route handlers and shared validators)
- Status defaults to `available`; downstream logic can mark rows as `booked` or `blocked`
- The backend does not automatically merge overlapping ranges—conflict handling is left to consumers

**Valid Status Values**:
- `available`: Open for booking requests
- `booked`: Already reserved by a guest
- `blocked`: Temporarily unavailable (host blocked dates)

**Database Schema**:
```sql
CREATE TABLE IF NOT EXISTS availabilities (
  id TEXT PRIMARY KEY,
  host_id TEXT NOT NULL,
  start_date TEXT NOT NULL,
  end_date TEXT NOT NULL,
  status TEXT DEFAULT 'available',
  notes TEXT
);

CREATE INDEX IF NOT EXISTS idx_availabilities_host_id ON availabilities(host_id);
CREATE INDEX IF NOT EXISTS idx_availabilities_dates ON availabilities(start_date, end_date);
CREATE INDEX IF NOT EXISTS idx_availabilities_status ON availabilities(status);
CREATE INDEX IF NOT EXISTS idx_availabilities_host_status ON availabilities(host_id, status);
```

---

### 4. BookingRequest Entity

**Purpose**: Represents a request from a guest to stay at a host's property during specific dates.

**Properties**:
- `id` (string): UUID primary key for the booking request
- `host_id` (string, required): Reference to the requested host property
- `requester_id` (string, required): ID of the guest making the request
- `start_date` / `end_date` (string, required): Requested date range (ISO strings)
- `guests` (number, required): Number of guests for the stay
- `message` (string | null): Optional personal message to the host
- `status` (string, required): Current status (`pending`, `approved`, `declined`, or `cancelled`)
- `response_message` (string | null): Optional host response message when the status changes
- `responded_at` (string | null): Timestamp of the last host response
- `created_at` (string, required): Timestamp when the request was created

**Relationships**:
- Many-to-One with `Host` (request is for a specific host)
- Many-to-One with `User` (request is made by a specific user)

**Business Rules**:
- Start date must be before end date (validated before inserts)
- Guest count is expected to respect the host's `max_guests`; this is currently enforced via UI and tests, not hard database constraints
- Requests are accepted for any date range; availability conflicts must be resolved at the application level
- Only authenticated users can make booking requests (enforced by frontend session handling)
- Hosts update the status and optional response message via `/booking-requests/:id/status`

**Valid Status Values**:
- `pending`: Awaiting host response
- `approved`: Host has accepted the request
- `declined`: Host has declined the request
- `cancelled`: Requester cancelled the request

**Database Schema**:
```sql
CREATE TABLE IF NOT EXISTS booking_requests (
  id TEXT PRIMARY KEY,
  host_id TEXT NOT NULL,
  requester_id TEXT NOT NULL,
  start_date TEXT NOT NULL,
  end_date TEXT NOT NULL,
  guests INTEGER NOT NULL,
  message TEXT,
  status TEXT DEFAULT 'pending',
  response_message TEXT,
  responded_at DATETIME,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_booking_requests_host_id ON booking_requests(host_id);
CREATE INDEX IF NOT EXISTS idx_booking_requests_requester_id ON booking_requests(requester_id);
CREATE INDEX IF NOT EXISTS idx_booking_requests_status ON booking_requests(status);
CREATE INDEX IF NOT EXISTS idx_booking_requests_dates ON booking_requests(start_date, end_date);
CREATE INDEX IF NOT EXISTS idx_booking_requests_created_at ON booking_requests(created_at);
```

---

### 5. Connection Entity

**Purpose**: Represents friendship/social connections between users on the platform.

**Properties**:
- `id` (string): UUID primary key for the connection
- `user_id` (string, required): ID of the user who initiated the connection
- `connected_user_id` (string, required): ID of the user being connected to
- `relationship` (string | null): Free-form relationship label (e.g., friend, family)
- `status` (string, required): Current status (`pending`, `accepted`, `blocked`)
- `created_at` (string): Timestamp of creation

**Relationships**:
- Many-to-One with `User` (for the initiating user)
- Many-to-One with `User` (for the connected user)

**Business Rules**:
- Users cannot connect to themselves (validated before insert)
- Connections are directional but the UI can display them symmetrically
- Blocking is represented by updating the status to `blocked`
- Relationship labels are optional metadata used for UI grouping

**Valid Status Values**:
- `pending`: Connection request sent but not yet accepted
- `accepted`: Both users are connected
- `blocked`: One user has blocked the other

**Database Schema**:
```sql
CREATE TABLE IF NOT EXISTS connections (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  connected_user_id TEXT NOT NULL,
  relationship TEXT,
  status TEXT DEFAULT 'pending',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_connections_user_id ON connections(user_id);
CREATE INDEX IF NOT EXISTS idx_connections_connected_user_id ON connections(connected_user_id);
CREATE INDEX IF NOT EXISTS idx_connections_status ON connections(status);
CREATE INDEX IF NOT EXISTS idx_connections_relationship ON connections(relationship);
```

---

### 6. Invitation Entity

**Purpose**: Represents invitations sent by existing users to invite connections to join the platform.

**Properties**:
- `id` (string): UUID primary key for the invitation
- `inviter_id` (string, required): ID of the user sending the invitation
- `invitee_email` (string, required): Email address of the person being invited
- `message` (string | null): Optional message included in the invite
- `token` (string, required): Unique token for the invitation link
- `status` (string, required): Current status (`pending`, `accepted`, `cancelled`)
- `expires_at` (string, required): Expiration timestamp
- `accepted_at` (string | null): When the invitation was accepted
- `created_at` (string, required): When the invitation was created

**Relationships**:
- Many-to-One with `User` (invitation is sent by a user)
- May link to `User` (if invitation is accepted and user registers)

**Business Rules**:
- Invitee email must be unique per active invitation (enforced via a partial unique index on `status = 'pending'`)
- Users can resend invitations after previous ones are accepted or cancelled
- The backend records invitation acceptance but does not yet auto-create connections; the UI can prompt users to connect manually
- Tokens are generated on the backend using `crypto.randomUUID()` and must remain unique

**Valid Status Values**:
- `pending`: Invitation sent but not yet accepted
- `accepted`: Invitation accepted and user registered
- `cancelled`: Invitation was cancelled by the inviter

**Database Schema**:
```sql
CREATE TABLE IF NOT EXISTS invitations (
  id TEXT PRIMARY KEY,
  inviter_id TEXT NOT NULL,
  invitee_email TEXT NOT NULL,
  message TEXT,
  token TEXT NOT NULL UNIQUE,
  status TEXT DEFAULT 'pending',
  expires_at DATETIME NOT NULL,
  accepted_at DATETIME,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_invitations_inviter_id ON invitations(inviter_id);
CREATE INDEX IF NOT EXISTS idx_invitations_invitee_email ON invitations(invitee_email);
CREATE INDEX IF NOT EXISTS idx_invitations_token ON invitations(token);
CREATE INDEX IF NOT EXISTS idx_invitations_status ON invitations(status);
CREATE INDEX IF NOT EXISTS idx_invitations_expires_at ON invitations(expires_at);
CREATE UNIQUE INDEX IF NOT EXISTS idx_invitations_pending_unique ON invitations(inviter_id, invitee_email) WHERE status = 'pending';
```

---

## Entity Relationships Diagram

```
User
├── hosts (1:N) → Host
├── connections (1:N) → Connection
├── invitations (1:N) → Invitation
└── booking_requests (1:N) → BookingRequest

Host
├── user (N:1) → User
├── availabilities (1:N) → Availability
└── booking_requests (1:N) → BookingRequest

Availability
└── host (N:1) → Host

BookingRequest
├── host (N:1) → Host
└── requester (N:1) → User

Connection
├── user (N:1) → User
└── connected_user (N:1) → User

Invitation
└── inviter (N:1) → User
```

> ℹ️  Production SQLite tables currently omit explicit `FOREIGN KEY` clauses; referential integrity is enforced at the application layer and asserted via tests.

---

## Supporting Platform Services

### File & Avatar Uploads

- `POST /api/upload-image` accepts multipart form uploads under the `image` field and returns a public URL in `/uploads`. Files are stored as-is with UUID filenames.
- `POST /api/upload-avatar` accepts an `avatar` file, requires a valid backend JWT (generated during NextAuth sign-in), resizes the image to 256×256 via Sharp, and stores it under `/avatars`. The response contains the canonical avatar URL and filename.
- Both endpoints enforce a 5 MB file size limit and restrict uploads to MIME types starting with `image/`.

### Community Statistics

The backend exposes lightweight counters to power the "Growing Community" section on the homepage:

- `GET /api/stats/hosts` → `{ count: number }` for total hosts
- `GET /api/stats/connections` → `{ count: number }` counting accepted connections
- `GET /api/stats/bookings` → `{ count: number }` counting booking requests with `status = 'approved'`

These routes rely on the prepared statements `getTotalHostsCount`, `getTotalConnectionsCount`, and `getTotalBookingsCount` defined in `apps/backend/src/db.ts`.

---

## Data Flow Patterns

### 1. User Registration & Authentication
1. User enters their email on the NextAuth sign-in screen
2. NextAuth creates a verification token via the minimal SQLite adapter (`verification-tokens.db`) and emails/logs the magic link
3. When the magic link is used, NextAuth issues a JWT session; the JWT callback fetches or creates the corresponding backend user via `/api/users`
4. The JWT payload includes `apiToken`, `backendUserId`, and profile fields, enabling authenticated REST calls to manage hosts, availabilities, connections, and bookings

### 2. Creating a Host Property
1. Authenticated user creates new Host entity
2. Host is linked to user via backend association
3. Host can optionally create initial Availability periods
4. Host becomes searchable by connected friends

### 3. Booking Flow
1. Guest searches for available properties
2. Guest selects dates and creates BookingRequest
3. Host receives notification of request
4. Host approves/declines request
5. If approved, Availability status may be updated to "booked"

### 4. Friend Connection Flow
1. User A sends connection request to User B (via email)
2. Connection entity created with "pending" status
3. User B accepts/declines the connection
4. If accepted, both users can see each other's hosts

### 5. Invitation Flow
1. Existing user sends invitation to friend via email
2. Invitation entity created with unique token and "pending" status
3. Friend receives email with invitation link containing token
4. Friend clicks link and registers new account
5. Upon successful registration, invitation status updates to "accepted"
6. Users can manually create a Connection once the invitee joins (auto-creation is a future enhancement)

---

## Business Rules & Constraints

### Data Integrity
- Email addresses must be unique across users
- Date ranges must be valid (start ≤ end)
- Guest count cannot exceed host capacity

### Privacy & Security
- Users only see hosts from connected friends
- Personal information is protected
- Email verification required for full platform access

### Availability Management
- Hosts control their availability calendars through the REST API
- Overlapping availabilities are currently allowed; orchestration is handled in the client workflows
- Booking requests should align with available periods; conflicts are handled in application logic

### Search & Discovery
- Search endpoints include name and location filters
- There is no `is_active` flag—visibility is determined purely by existing records
- Geographic coordinates enable map-based discovery in the frontend map preview
- Connection relationships provide context for host discovery

---

## Future Considerations

### Potential Entity Extensions

**Review Entity**: Post-stay reviews and ratings
```typescript
interface Review {
  id: string
  bookingRequestId: string
  reviewerId: string
  revieweeId: string
  rating: number
  comment: string
  createdAt: string
}
```

**Notification Entity**: System notifications and messages
```typescript
interface Notification {
  id: string
  userId: string
  type: string
  title: string
  message: string
  read: boolean
  createdAt: string
}
```

**Payment Entity**: Financial transactions (if monetization added)
```typescript
interface Payment {
  id: string
  bookingRequestId: string
  amount: number
  currency: string
  status: string
  createdAt: string
}
```

### Scalability Considerations
- Database indexing on frequently queried fields
- Caching for search results and availability data
- Image storage optimization for property photos
- Geographic search optimization for location-based queries

This entity specification provides a complete foundation for the Stay With Friends application, enabling trusted accommodation sharing between friends while maintaining data integrity and user privacy.